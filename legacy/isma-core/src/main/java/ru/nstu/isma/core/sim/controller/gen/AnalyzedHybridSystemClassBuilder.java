package ru.nstu.isma.core.sim.controller.gen;

import com.google.common.collect.ImmutableMap;
import common.HMExpressionBuilder;
import org.apache.commons.lang3.text.StrSubstitutor;
import ru.nstu.isma.core.hsm.HSM;
import ru.nstu.isma.core.hsm.events.HSMEventFunctionGroup;
import ru.nstu.isma.core.hsm.events.HSMEventFunctionGroupEvaluator;
import ru.nstu.isma.core.hsm.exp.EXPOperator;
import ru.nstu.isma.core.hsm.exp.HMExpression;
import ru.nstu.isma.core.hsm.hybrid.HMPseudoState;
import ru.nstu.isma.core.hsm.hybrid.HMState;
import ru.nstu.isma.core.hsm.hybrid.HMTransaction;
import ru.nstu.isma.core.hsm.var.HMAlgebraicEquation;
import ru.nstu.isma.core.hsm.var.HMDerivativeEquation;
import ru.nstu.isma.intg.api.calcmodel.*;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @author Maria Nasyrova
 * @since 05.10.2015
 */
public class AnalyzedHybridSystemClassBuilder {

    private static final List<Class<?>> IMPORT_CLASSES = Arrays.asList(
            DifferentialEquation.class,
            AlgebraicEquation.class,
            HybridSystem.class,
            HybridSystemBuilder.class,
            Guard.class,
            EventFunctionGroup.class,
            EventFunction.class
    );

    private static final String GENERATED_CLASS_TEMPLATE = "" +
            "package ${packageName};\n" +
            "${importStatements}\n" +
            "\n" +
            "/**\n" +
            " * Generated by ISMA\n" +
            " */\n" +
            "public class ${className} extends HybridSystem {\n" +
            "\tpublic ${className}() {\n" +
            "\t\tsuper(hybridSystemBuilder().toHybridSystem());\n" +
            "\t}\n" +
            "\n" +
            "\tpublic static HybridSystemBuilder hybridSystemBuilder() {\n" +
            "\t\tHybridSystemBuilder hsb = new HybridSystemBuilder();\n" +
            "\n" +
            "${hsbBody}\n" +
            "\n" +
            "\t\treturn hsb;\n" +
            "\t}\n" +
            "\n" +
            "}\n";

    private final HSM hsm;
    private final String packageName;
    private final String className;

    private final EquationIndexProvider indexProvider;
    private final HMExpressionBuilder hmExpressionBuilder;

    public AnalyzedHybridSystemClassBuilder(HSM hsm, EquationIndexProvider indexProvider, String packageName, String className) {
        this.hsm = hsm;
        this.indexProvider = indexProvider;
        this.packageName = packageName;
        this.className = className;
        this.hmExpressionBuilder = new HMExpressionBuilder(indexProvider);
    }

    public String buildSourceCode() {
        ImmutableMap<String, String> values = ImmutableMap.of(
                "packageName", packageName,
                "importStatements", renderImports(IMPORT_CLASSES),
                "className", className,
                "hsbBody", renderHsbBody()
        );
        return StrSubstitutor.replace(GENERATED_CLASS_TEMPLATE, values);
    }

    private String renderImports(Collection<Class<?>> classes) {
        final String template = "\nimport %s;";
        return classes.stream()
                .map(Class::getCanonicalName)
                .map(className -> String.format(template, className))
                .collect(Collectors.joining());
    }

    private String renderHsbBody() {
        final String template = "" +
                "${initState}" +
                "${states}" +
                "${initPseudoState}" +
                "${pseudoStates}";
        return StrSubstitutor.replace(template, ImmutableMap.of(
                "initState", renderInitState(),
                "states", renderStates(),
                "initPseudoState", renderInitPseudoState(),
                "pseudoStates", renderPseudoStates()
        ));
    }

    private String renderInitState() {
        final String template = "\t\t" +
                "hsb.addState(\"${stateCode}\")" +
                "${differentialEquations}" +
                "${algebraicEquations}" +
                "${guards}" +
                "${setters};";

        return StrSubstitutor.replace(template, ImmutableMap.of(
                "stateCode", HSM.INIT_STATE,
                "differentialEquations", renderDifferentialEquations(hsm.getVariableTable().getOdes()),
                "algebraicEquations", renderAlgebraicEquations(hsm.getVariableTable().getAlgs()),
                "guards", renderGuards(getTransactions(HSM.INIT_STATE)),
                "setters", renderSetters(hsm.getVariableTable().getSetters())
        ));
    }

    private String renderStates() {
        return hsm.getAutomata().getStates().values().stream()
                .filter(state -> !HSM.INIT_STATE.equals(state.getCode()))
                .map(this::renderState)
                .collect(Collectors.joining());
    }

    private String renderState(HMState state) {
        final String template = "\n\n\t\t" +
                "hsb.addState(\"${stateCode}\")" +
                "${differentialEquations}" +
                "${algebraicEquations}" +
                "${guards}" +
                "${setters};";

        return StrSubstitutor.replace(template, ImmutableMap.<String, String> builder()
                .put("stateCode", state.getCode())
                .put("differentialEquations", renderDifferentialEquations(state.getVariables().getOdes()))
                .put("algebraicEquations", renderAlgebraicEquations(state.getVariables().getAlgs()))
                .put("guards", renderGuards(getTransactions(state.getCode())))
                .put("setters", renderSetters(state.getVariables().getSetters()))
                .build()
        );
    }

    private String renderInitPseudoState() {
        if (hsm.getAutomata().getAllPseudoStates().isEmpty()) {
            return "";
        }

        final String template = "\n\n\t\t" +
                "hsb.addPseudoState(\"${stateCode}\")" +
                "${guards};";

        String guards = hsm.getAutomata().getAllPseudoStates().stream()
                .map(ps -> renderGuard(HybridSystem.INIT_PSEUDO_STATE, ps.getCode(), ps.getCondition()))
                .collect(Collectors.joining());

        return StrSubstitutor.replace(template, ImmutableMap.of(
                "stateCode", HybridSystem.INIT_PSEUDO_STATE,
                "guards", guards
        ));
    }

    private String renderPseudoStates() {
        return hsm.getAutomata().getAllPseudoStates().stream()
                .map(this::renderPseudoState)
                .collect(Collectors.joining());
    }

    private String renderPseudoState(HMPseudoState state) {
        final String template = "\n\n\t\t" +
                "hsb.addPseudoState(\"${stateCode}\")" +
                "${differentialEquations}" +
                "${algebraicEquations}" +
                "${setters};";

        return StrSubstitutor.replace(template, ImmutableMap.of(
                "stateCode", state.getCode(),
                "differentialEquations", renderDifferentialEquations(state.getVariables().getOdes()),
                "algebraicEquations", renderAlgebraicEquations(state.getVariables().getAlgs()),
                "setters", renderSetters(state.getVariables().getSetters())
        ));
    }

    private Collection<HMTransaction> getTransactions(String fromStateCode) {
        return hsm.getAutomata().getTransactions().stream()
                .filter(t -> t.getSource().getCode().equals(fromStateCode))
                .collect(Collectors.toSet());
    }

    private String renderDifferentialEquations(Collection<HMDerivativeEquation> odes) {
        final String template = "\n\t\t\t" + ".add${deClassName}(${de})";
        return odes.stream().map(ode -> StrSubstitutor.replace(template, ImmutableMap.of(
                "deClassName", DifferentialEquation.class.getSimpleName(),
                "de", renderDifferentialEquation(ode.getCode(), ode.getRightPart())
        ))).collect(Collectors.joining());
    }

    private String renderDifferentialEquation(String code, HMExpression rightPart) {
        final String template = "new ${deClassName}(\"${name}\", ${index}, ${de})";
        final String de = renderWithRhs(rightPart);
        return StrSubstitutor.replace(template, ImmutableMap.of(
                "deClassName", DifferentialEquation.class.getSimpleName(),
                "index", Integer.toString(indexProvider.getDifferentialEquationIndex(code)),
                "name", code,
                "de", de
        ));
    }

    private String renderWithRhs(HMExpression rightPart) {
        final String template = "(y, rhs) -> (${expression}), \"${desc}\"";
        String expression = hmExpressionBuilder.buildExpression(rightPart, false, true);
        return StrSubstitutor.replace(template, ImmutableMap.of(
                "expression", expression,
                "desc", expression
        ));
    }

    private String renderAlgebraicEquations(Collection<HMAlgebraicEquation> algEquations) {
        final String template = "\n\t\t\t" +
                ".add${aeClassName}(new ${aeClassName}(\"${name}\", ${index}, (y, a) -> (${expression}), \"${desc}\"))";
        return algEquations.stream().map(ae -> {
            String expression = hmExpressionBuilder.buildExpression(ae.getRightPart(), true);
            return StrSubstitutor.replace(template, ImmutableMap.of(
                    "aeClassName", AlgebraicEquation.class.getSimpleName(),
                    "index", Integer.toString(indexProvider.getAlgebraicEquationIndex(ae.getCode())),
                    "name", ae.getCode(),
                    "expression", expression,
                    "desc", expression
            ));
        }).collect(Collectors.joining());
    }

    private String renderGuards(Collection<HMTransaction> transactions) {
        return transactions.stream()
                .map(t -> renderGuard(t.getSource().getCode(), t.getTarget().getCode(), t.getCondition()))
                .collect(Collectors.joining());
    }

    private String renderGuard(String fromState, String toState, HMExpression rightPart) {
        final String template = "\n\t\t\t" +
                ".addGuard(new Guard(\"${from}\", \"${to}\", ${condition}))" +
                "${eventFunctionGroup}";
        return StrSubstitutor.replace(template, ImmutableMap.of(
                "from", fromState,
                "to", toState,
                "condition", renderWithRhs(rightPart),
                "eventFunctionGroup", renderEventFunctionGroup(rightPart)
        ));
    }

    private String renderSetters(Map<String, HMExpression> setters) {
        final String template = "\n\t\t\t" + ".addSetter(${de})";
        return setters.entrySet().stream().map(entry -> StrSubstitutor.replace(template, ImmutableMap.of(
                "de", renderDifferentialEquation(entry.getKey(), entry.getValue())
        ))).collect(Collectors.joining());
    }

    private String renderEventFunctionGroup(HMExpression guard) {
        final String template = "\n\t\t\t\t" + ".addEventFunctionGroup(${stepChoiceRule})" +
                "${eventFunctions}";

        HSMEventFunctionGroup eventFunctionGroup = HSMEventFunctionGroupEvaluator.evaluate(guard);

        return StrSubstitutor.replace(template, ImmutableMap.of(
                "stepChoiceRule", renderStepChoiceRule(eventFunctionGroup),
                "eventFunctions", renderEventFunctions(eventFunctionGroup)
        ));
    }

    private String renderStepChoiceRule(HSMEventFunctionGroup eventFunctionGroup) {
        EXPOperator.Code operatorCode = eventFunctionGroup.getOperatorCode();
        String ruleValue = null;

        if (operatorCode == null) {
            ruleValue = EventFunctionGroup.StepChoiceRule.NONE.name();
        } else if (operatorCode.equals(EXPOperator.Code.AND)) {
            ruleValue = EventFunctionGroup.StepChoiceRule.MAX.name();
        } else if (operatorCode.equals(EXPOperator.Code.OR)) {
            ruleValue = EventFunctionGroup.StepChoiceRule.MIN.name();
        } else {
            throw new IllegalArgumentException("Unknown operator code \"" + operatorCode + "\"");
        }

        return EventFunctionGroup.class.getSimpleName() + "." +
               EventFunctionGroup.StepChoiceRule.class.getSimpleName() + "." +
               ruleValue;
    }

    private String renderEventFunctions(HSMEventFunctionGroup eventFunctionGroup) {
        return eventFunctionGroup.getExpressions().stream()
                .map(this::renderEventFunction)
                .collect(Collectors.joining());
    }

    private String renderEventFunction(HMExpression eventFunctionExpression) {
        final String template = "\n\t\t\t\t\t" + ".addEventFunction(new EventFunction(${expression}))";
        return StrSubstitutor.replace(template, ImmutableMap.of(
                "expression", renderWithRhs(eventFunctionExpression)
        ));
    }
}
